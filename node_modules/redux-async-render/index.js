"use strict";
/// <reference path="redux.d.ts" />
var redux_1 = require('redux');
var Bluebird = require('bluebird');
var debug = require('debug')('redux-async-render');
var isPromise = function (promise) { return promise && typeof promise.then === 'function'; };
// istanbul ignore next
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    console.warn('You shouldn\'t include redux-async-render in client-side code');
}
exports.serverHelper = function (createStore) {
    return function (reducer, initialState) {
        var promises = new Array();
        function observePromise(state, promise) {
            if (!isPromise(promise)) {
                return promise;
            }
            // debug('found promise while state is ', state);
            // wrap promises in bluebird.resolve so we can access #isResolved etc.
            promises.push(Bluebird.resolve(promise));
            return promise;
        }
        var middleware = function (_a) {
            var getState = _a.getState;
            return function (next) { return function (action) {
                var state = getState();
                // debug('#dispatch(%s) with state (%j)', action && action.type || typeof action, state);
                return observePromise(state, next(observePromise(state, action)));
            }; };
        };
        var store = redux_1.applyMiddleware(middleware)(createStore)(reducer, initialState);
        store.promises = promises;
        return store;
    };
};
function _renderAsync(store, renderFn, promises) {
    // render at each loop so we detect promises
    var rendered = renderFn(store);
    // find unresolved promises
    var unresolved = promises.filter(function (promise) { return !promise.isResolved(); });
    debug('we found %s unresolved promises', unresolved.length);
    if (unresolved.length === 0) {
        debug('returning rendered version');
        return Bluebird.resolve(rendered);
    }
    return Bluebird.all(unresolved).then(function () {
        // recursive in case new promises were introduced.
        return _renderAsync(store, renderFn, promises);
    });
}
function renderAsync(store, renderFn) {
    var promises = store.promises;
    if (!promises) {
        throw new Error('You need to create the store with serverHelper before calling renderAsync');
    }
    debug('renderAsync: %d promise(s)', promises.length);
    return _renderAsync(store, renderFn, promises);
}
exports.renderAsync = renderAsync;
//# sourceMappingURL=index.js.map